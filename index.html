<!doctype html>
<html lang="vi">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Perlin Noise Mountains ‚Äî Three.js r128</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #0b1020;
            color: #e7f2ff;
            font-family: system-ui, Roboto, sans-serif;
        }

        #app {
            position: fixed;
            inset: 0;
        }

        .badge {
            position: fixed;
            left: 12px;
            bottom: 12px;
            padding: 6px 6px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(8px);
            border-radius: 10px;
            font-size: 10px;
        }
    </style>

    <!-- Three.js / Controls / dat.GUI -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Water.js"></script>
</head>

<body>
    <div id="app"></div>
    <div class="badge">Perlin Mountains ‚Ä¢ Three.js r128</div>
    <canvas id="minimap" width="100" height="100"
        style="position: absolute; right: 20px; bottom: 20px; border:1px solid #fff; background:#111; cursor:pointer;"></canvas>

    <script>
        // ===== Seeded random helper =====
        function xorshift32(seed) {
            let x = seed >>> 0;
            return function () {
                // xorshift
                x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
                // to [0,1)
                return ((x >>> 0) / 4294967296);
            };
        }

        // ===== Perlin Noise (2D), seeded =====
        function makePerlin2D(seed = 12345) {
            const rand = xorshift32(seed || 1);
            const p = new Uint8Array(512);
            const perm = new Uint8Array(256);
            for (let i = 0; i < 256; i++) perm[i] = i;
            // Fisher-Yates shuffle using seeded rng
            for (let i = 255; i > 0; i--) {
                const j = Math.floor(rand() * (i + 1));
                const tmp = perm[i]; perm[i] = perm[j]; perm[j] = tmp;
            }
            for (let i = 0; i < 512; i++) p[i] = perm[i & 255];

            const Gx = new Float32Array(512);
            const Gy = new Float32Array(512);
            for (let i = 0; i < 512; i++) {
                // Random unit gradients
                const a = rand() * Math.PI * 2;
                Gx[i] = Math.cos(a);
                Gy[i] = Math.sin(a);
            }

            function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            function lerp(a, b, t) { return a + (b - a) * t; }
            function grad(ix, iy, x, y) {
                const idx = p[ix + p[iy]];
                return Gx[idx] * x + Gy[idx] * y;
            }

            function noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const xf = x - Math.floor(x);
                const yf = y - Math.floor(y);

                const u = fade(xf);
                const v = fade(yf);

                const n00 = grad(X, Y, xf, yf);
                const n10 = grad(X + 1, Y, xf - 1, yf);
                const n01 = grad(X, Y + 1, xf, yf - 1);
                const n11 = grad(X + 1, Y + 1, xf - 1, yf - 1);

                const nx0 = lerp(n00, n10, u);
                const nx1 = lerp(n01, n11, u);
                const nxy = lerp(nx0, nx1, v);
                return nxy; // in ~[-1,1]
            }

            return { noise };
        }

        // fBm (fractal Brownian motion) using Perlin
        function fbm2(perlin, x, y, octaves = 4, lacunarity = 2.0, gain = 0.5) {
            let amp = 0.5, freq = 1.0, sum = 0.0, norm = 0.0;
            for (let i = 0; i < octaves; i++) {
                sum += amp * perlin.noise(x * freq, y * freq);
                norm += amp;
                amp *= gain;
                freq *= lacunarity;
            }
            return sum / norm; // ~[-1,1]
        }

        // ===== Three.js setup =====
        const app = document.getElementById('app');
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.setSize(innerWidth, innerHeight);
        renderer.shadowMap.enabled = true;
        app.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b1020);

        const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 5000);
        camera.position.set(300, 260, 300);
        scene.add(camera);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI * 0.495;

        // Lights
        const hemi = new THREE.HemisphereLight(0x7aa6ff, 0x2e2e2e, 0.7);
        scene.add(hemi);

        const dir = new THREE.DirectionalLight(0xffffff, 1.0);
        dir.position.set(-300, 400, 200);
        dir.castShadow = true;
        dir.shadow.mapSize.set(2048, 2048);
        const d = 500;
        dir.shadow.camera.left = -d; dir.shadow.camera.right = d;
        dir.shadow.camera.top = d; dir.shadow.camera.bottom = -d;
        scene.add(dir);

        // Ground (receive shadow)
        const ground = new THREE.Mesh(
            new THREE.PlaneBufferGeometry(4000, 4000),
            new THREE.ShadowMaterial({ opacity: 0.15 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1;
        ground.receiveShadow = true;
        scene.add(ground);

        // ===== Terrain params & GUI =====
        const params = {
            width: 600, depth: 600, // k√≠ch th∆∞·ªõc m·∫∑t ph·∫≥ng
            segments: 256,          // ƒë·ªô ph√¢n gi·∫£i (256 x 256)
            amplitude: 80,          // bi√™n ƒë·ªô ƒë·ªìi n√∫i
            frequency: 0.0035,      // t·∫ßn s·ªë c∆° s·ªü (scale)
            octaves: 5,             // s·ªë t·∫ßng fBm
            lacunarity: 2.0,        // nh√¢n t·∫ßn s·ªë m·ªói t·∫ßng
            gain: 0.5,              // gi·∫£m bi√™n ƒë·ªô m·ªói t·∫ßng
            seed: 1337,             // seed ƒë·ªÉ t√°i t·∫°o
            wireframe: false,
            flatShading: true,
            metalness: 0.1,
            roughness: 0.95,
            autoRotate: false,
            showMinimap: false,
            // th√™m v√†o params
            rain: false,
            flow: false,            // l√†m ƒë·ªãa h√¨nh ‚Äúch·∫£y‚Äù theo th·ªùi gian
            flowSpeed: 0.08,        // t·ªëc ƒë·ªô "ch·∫£y"
            elevationBias: 0.0,     // ƒë·∫©y to√†n b·ªô cao ƒë·ªô l√™n/xu·ªëng
            waterHeight: 0,   // cao ƒë·ªô m·∫∑t n∆∞·ªõc so v·ªõi g·ªëc to·∫° ƒë·ªô Y
            Regenerate: () => buildTerrain(true)
        };

        const texLoader = new THREE.TextureLoader();
        params.texture = texLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');

        // N√∫t ch·ªçn ·∫£nh
        const fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = ".image/*";
        fileInput.style.display = "none";
        document.body.appendChild(fileInput);
        fileInput.addEventListener("change", (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            const loader = new THREE.TextureLoader();
            loader.load(url, (texture) => {
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                texture.minFilter = THREE.LinearFilter;

                const imgWidth = texture.image.width;
                const imgHeight = texture.image.height;
                const aspect = imgWidth / imgHeight;

                const planeWidth = params.width;
                const planeHeight = params.depth;
                const planeAspect = planeWidth / planeHeight;

                if (aspect > planeAspect) {
                    // ·∫¢nh r·ªông h∆°n plane
                    const scale = planeAspect / aspect;
                    texture.repeat.set(1, scale);
                    texture.offset.set(0, (1 - scale) / 2);
                } else {
                    // ·∫¢nh cao h∆°n plane
                    const scale = aspect / planeAspect;
                    texture.repeat.set(scale, 1);
                    texture.offset.set((1 - scale) / 2, 0);
                }

                terrainMat.map = texture;
                terrainMat.needsUpdate = true;
            });
        });
        // === Ripple system ===
        let ripples = [];

        function createRipple(x, z) {
            const geom = new THREE.RingGeometry(0.1, 0.15, 32);
            const mat = new THREE.MeshBasicMaterial({
                color: 0x66ccff,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const ripple = new THREE.Mesh(geom, mat);
            ripple.rotation.x = -Math.PI / 2; // n·∫±m ngang
            ripple.position.set(x, params.waterHeight + 0.2, z);
            ripple.userData = { scale: 0.1, life: 1.0 }; // scale ban ƒë·∫ßu, ƒë·ªô s·ªëng
            scene.add(ripple);
            ripples.push(ripple);
        }

        // C·∫≠p nh·∫≠t ripple trong tick()
        function updateRipples(delta) {
            for (let i = ripples.length - 1; i >= 0; i--) {
                const r = ripples[i];
                r.userData.scale += 1.5 * delta; // t·ªëc ƒë·ªô n·ªü
                r.scale.set(r.userData.scale, r.userData.scale, 1);

                r.userData.life -= 0.5 * delta; // m·ªù d·∫ßn
                r.material.opacity = r.userData.life * 0.5;

                if (r.userData.life <= 0) {
                    scene.remove(r);
                    ripples.splice(i, 1);
                }
            }
        }

        let rainGroup;
        function createRain() {
            const rainCount = 2000; // s·ªë l∆∞·ª£ng h·∫°t m∆∞a
            const geometry = new THREE.BufferGeometry();
            const positions = [];

            for (let i = 0; i < rainCount; i++) {
                const x = (Math.random() - 0.5) * params.width * 3;
                const y = Math.random() * 500 + 100;
                const z = (Math.random() - 0.5) * params.depth * 3;
                positions.push(x, y, z);
            }

            geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0x66ccff,
                size: 2,
                transparent: true,
                opacity: 0.8,
                depthWrite: false
            });

            rainGroup = new THREE.Points(geometry, material);
            scene.add(rainGroup);
        }
        let perlin = makePerlin2D(params.seed);
        let terrain, terrainGeom, terrainMat;
        let time = 0;
        let water;

        function buildTerrain(newSeed = false) {
            if (newSeed) {
                params.seed = Math.floor(Math.random() * 1e9) >>> 0;
                perlin = makePerlin2D(params.seed);
            }
            // Dispose old
            if (terrain) {
                terrain.geometry.dispose();
                terrain.material.dispose();
                scene.remove(terrain);
            }
            terrainGeom = new THREE.PlaneBufferGeometry(params.width, params.depth, params.segments, params.segments);
            terrainGeom.rotateX(-Math.PI / 2);

            // T·∫°o m·∫£ng m√†u cho t·ª´ng vertex
            const colors = [];
            const position = terrainGeom.attributes.position;
            for (let i = 0; i < position.count; i++) {
                const y = position.getY(i); // d√πng cao ƒë·ªô Y sau khi updateHeights
                let color;
                if (y < params.waterHeight) {
                    color = new THREE.Color(0x003333);
                } else {
                    color = new THREE.Color(0xffffff);
                }
                colors.push(color.r, color.g, color.b);
            }

            terrainGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            terrainMat = new THREE.MeshStandardMaterial({
                flatShading: params.flatShading,
                wireframe: params.wireframe,
                metalness: params.metalness,
                roughness: params.roughness,
                vertexColors: true   // b·∫≠t d√πng m√†u theo vertex
            });


            if (params.texture) {
                terrainMat.map = params.texture;
                terrainMat.map.wrapS = terrainMat.map.wrapT = THREE.RepeatWrapping;
                terrainMat.map.repeat.set(8, 8);
            }

            terrain = new THREE.Mesh(terrainGeom, terrainMat);
            terrain.castShadow = true;
            terrain.receiveShadow = true;
            scene.add(terrain);

            // Gradient background
            const canvas = document.createElement("canvas");
            canvas.width = 1;
            canvas.height = 256;
            const ctx = canvas.getContext("2d");

            // T·∫°o gradient t·ª´ xanh nh·∫°t -> xanh ƒë·∫≠m
            const gradient = ctx.createLinearGradient(0, 0, 0, 256);
            gradient.addColorStop(0, "#87ceeb");  // xanh tr·ªùi
            gradient.addColorStop(1, "#00111a");  // xanh ƒë·∫≠m g·∫ßn ch√¢n tr·ªùi
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1, 256);

            const skyTexture = new THREE.CanvasTexture(canvas);
            scene.background = skyTexture;

            // N∆∞·ªõc
            if (water) {
                water.geometry.dispose();
                water.material.dispose();
                scene.remove(water);
                water = null;
            }
            const waterGeom = new THREE.BoxGeometry(params.width, params.depth);
            water = new THREE.Water(waterGeom, {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: new THREE.TextureLoader().load(
                    "https://threejs.org/examples/textures/waternormals.jpg",
                    function (texture) {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    }
                ),
                alpha: 1.0,
                sunDirection: dir.position.clone().normalize(),
                sunColor: 0xffffff,
                waterColor: 0x001e0f,
                distortionScale: 3.7,
                fog: scene.fog !== undefined
            });
            water.rotation.x = -Math.PI / 2;      // ƒë·∫∑t n·∫±m ngang
            water.position.y = params.waterHeight; // cao ƒë·ªô m·∫∑t n∆∞·ªõc
            scene.add(water);

            updateHeights(0);
            updateColors();
        }
        function updateColors() {
            const colors = [];
            const position = terrainGeom.attributes.position;
            const snowHeight = 250; // cao ƒë·ªô xu·∫•t hi·ªán tuy·∫øt
            for (let i = 0; i < position.count; i++) {
                const y = position.getY(i);
                let color;
                if (y < params.waterHeight) {
                    color = new THREE.Color(0x0011ff);
                } else if (y > snowHeight) {
                    color = new THREE.Color(0xffffff); // tuy·∫øt tr√™n ƒë·ªânh
                } else {
                    color = new THREE.Color(0x00ff40);
                }
                colors.push(color.r, color.g, color.b);
            }
            terrainGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        }

        function updateHeights(t) {
            const pos = terrainGeom.attributes.position;
            const arr = pos.array;

            // L·∫•y th√¥ng tin l∆∞·ªõi
            const segX = params.segments;
            const segZ = params.segments;
            const halfW = params.width * 0.5;
            const halfD = params.depth * 0.5;

            // offset ‚Äúflow‚Äù theo th·ªùi gian
            const tOffset = params.flow ? t * params.flowSpeed : 0;

            // Duy·ªát t·ª´ng ƒë·ªânh: PlaneBufferGeometry sinh ƒë·ªânh theo tr·∫≠t t·ª± ƒë·ªÅu
            for (let iz = 0; iz <= segZ; iz++) {
                for (let ix = 0; ix <= segX; ix++) {
                    const i = ix + iz * (segX + 1);
                    const i3 = i * 3;

                    const x = arr[i3 + 0];
                    const z = arr[i3 + 2];

                    // ƒê∆∞a x,z v·ªÅ kh√¥ng gian noise [d·ª±a t·∫ßn s·ªë]
                    const nx = (x + tOffset * 80) * params.frequency;
                    const nz = (z + tOffset * 80) * params.frequency;

                    // fBm Perlin
                    let h = fbm2(perlin, nx, nz, params.octaves, params.lacunarity, params.gain);
                    // Nh·∫•n m·∫°nh ƒë·ªânh, n√©n ƒë√°y (m·ªÅm h∆°n)
                    h = Math.sign(h) * Math.pow(Math.abs(h), 1.2);

                    const y = h * params.amplitude + params.elevationBias;
                    arr[i3 + 1] = y;
                }
            }

            pos.needsUpdate = true;
            terrainGeom.computeVertexNormals();
            terrainGeom.normalsNeedUpdate = true;
        }

        // GUI
        const gui = new dat.GUI();
        const fTerrain = gui.addFolder('Terrain');
        fTerrain.add(params, 'width', 100, 2000, 10).onFinishChange(() => buildTerrain(false));
        fTerrain.add(params, 'depth', 100, 2000, 10).onFinishChange(() => buildTerrain(false));
        fTerrain.add(params, 'segments', 32, 1024, 1).onFinishChange(() => buildTerrain(false));
        fTerrain.add(params, 'amplitude', 1, 1000, 1).onFinishChange(() => buildTerrain(false));
        fTerrain.add(params, 'frequency', 0.0005, 0.02, 0.0001).onFinishChange(() => buildTerrain(false));
        fTerrain.add(params, 'octaves', 1, 8, 1).onFinishChange(() => buildTerrain(false));
        fTerrain.add(params, 'lacunarity', 1.5, 3.5, 0.1).onFinishChange(() => buildTerrain(false));
        fTerrain.add(params, 'gain', 0.2, 0.9, 0.01).onFinishChange(() => buildTerrain(false));
        fTerrain.add(params, 'elevationBias', -100, 100, 1).onChange(v => {
            updateHeights(time);
            updateColors();
        });
        fTerrain.add(params, 'waterHeight', -100, 300, 1).onChange(v => {
            if (water) water.position.y = v;
            updateColors();
        });
        fTerrain.add(params, 'Regenerate');

        const fMat = gui.addFolder('Material');
        fMat.add(params, 'wireframe').onChange(v => { terrainMat.wireframe = v; terrainMat.needsUpdate = true; });
        fMat.add(params, 'flatShading').onChange(v => { terrainMat.flatShading = v; terrainMat.needsUpdate = true; buildTerrain(false); });
        fMat.add(params, 'metalness', 0, 1, 0.01).onChange(v => terrainMat.metalness = v);
        fMat.add(params, 'roughness', 0, 1, 0.01).onChange(v => terrainMat.roughness = v);
        fMat.add({ useTexture: true }, 'useTexture').name('Use Texture').onChange(v => {
            if (v) {
                terrainMat.map = params.texture;
                terrainMat.map.wrapS = terrainMat.map.wrapT = THREE.RepeatWrapping;
                terrainMat.map.repeat.set(8, 8);
            } else {
                terrainMat.map = null;
            }
            terrainMat.needsUpdate = true;
        });
        

        fMat.add({ chooseTexture: () => fileInput.click() }, 'chooseTexture').name("Choose Texture");

        // GUI toggle
        const fWeather = gui.addFolder("Weather");
        fWeather.add(params, "rain").name("Rain").onChange(v => {
            if (v) {
                if (!rainGroup) createRain();
                rainGroup.visible = true;
            } else if (rainGroup) {
                rainGroup.visible = false;
            }
        });
        const fView = gui.addFolder('View');
        fView.add(params, 'autoRotate');
        fView.add(params, 'flow');
        fView.add(params, 'flowSpeed', 0.0, 0.6, 0.01);
        fView.add(params, 'showMinimap').name("Show Minimap").onChange(v => {
            minimap.style.display = v ? "block" : "none";
        });

        // N√∫t ch·ª•p ·∫£nh
        const fCapture = gui.addFolder("Capture");
        fCapture.add({
            screenshot: () => {
                renderer.render(scene, camera); // ƒë·∫£m b·∫£o render frame m·ªõi nh·∫•t
                renderer.domElement.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = "terrain_screenshot.png";
                    a.click();
                    URL.revokeObjectURL(url);
                });
            }
        }, 'screenshot').name("Take Screenshot");
        // Th√™m v√†o GUI Capture ho·∫∑c t·∫°o folder ri√™ng
        fCapture.add({
            downloadParams: () => {
                // T·∫°o b·∫£n sao c√°c th√¥ng s·ªë quan tr·ªçng
                const exportParams = { ...params };
                // Lo·∫°i b·ªè c√°c h√†m kh·ªèi export
                Object.keys(exportParams).forEach(key => {
                    if (typeof exportParams[key] === "function") delete exportParams[key];
                });
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportParams, null, 2));
                const a = document.createElement("a");
                a.href = dataStr;
                a.download = "terrain_params.json";
                a.click();
            }
        }, 'downloadParams').name("Download Params");
        // T·∫°o input file ·∫©n
        const jsonInput = document.createElement("input");
        jsonInput.type = "file";
        jsonInput.accept = ".json";
        jsonInput.style.display = "none";
        document.body.appendChild(jsonInput);

        // Th√™m n√∫t v√†o GUI ƒë·ªÉ ch·ªçn t·ªáp JSON
        fCapture.add({
            loadParams: () => jsonInput.click()
        }, 'loadParams').name("Load Params");

        // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng ch·ªçn t·ªáp
        jsonInput.addEventListener("change", (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const loadedParams = JSON.parse(event.target.result);

                    // C·∫≠p nh·∫≠t params, b·ªè qua texture
                    Object.keys(loadedParams).forEach(key => {
                        if (key === "texture") return; // b·ªè qua
                        if (key in params) params[key] = loadedParams[key];
                    });

                    // C·∫≠p nh·∫≠t GUI
                    for (let i in gui.__folders) {
                        const folder = gui.__folders[i];
                        folder.__controllers.forEach(ctrl => {
                            if (ctrl.property in loadedParams) ctrl.setValue(loadedParams[ctrl.property]);
                        });
                    }

                    // N·∫øu JSON c√≥ texture.image, th·ª≠ load texture
                    if (loadedParams.texture && loadedParams.texture.image) {
                        const imgId = loadedParams.texture.image; // ho·∫∑c ƒë·ªïi th√†nh URL n·∫øu b·∫°n c√≥
                        const loader = new THREE.TextureLoader();
                        loader.load(imgId, (texture) => {
                            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                            terrainMat.map = texture;
                            terrainMat.needsUpdate = true;
                        });
                    }

                    buildTerrain(false);
                    if (params.waterHeight && water) water.position.y = params.waterHeight;

                } catch (err) {
                    alert("File JSON kh√¥ng h·ª£p l·ªá: " + err.message);
                }
            };

            reader.readAsText(file);
        });

        // Build first terrain
        buildTerrain(false);

        // Handle resize
        addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
        // ===== Mini Map =====
        const minimap = document.getElementById("minimap");
        minimap.style.display = "none"; // üö© ·∫©n ngay t·ª´ ƒë·∫ßu
        const ctxMap = minimap.getContext("2d");

        let isDraggingMini = false;
        let cameraTargetPos = new THREE.Vector3();
        let isCameraMoving = false;

        // V·∫Ω minimap
        function drawMinimap() {
            ctxMap.clearRect(0, 0, minimap.width, minimap.height);

            // V·∫Ω bi√™n ƒë·ªãa h√¨nh
            ctxMap.strokeStyle = "#0f0";
            ctxMap.strokeRect(0, 0, minimap.width, minimap.height);

            // V·∫Ω marker camera
            const camX = (camera.position.x / params.width + 0.5) * minimap.width;
            const camZ = (camera.position.z / params.depth + 0.5) * minimap.height;

            ctxMap.fillStyle = "red";
            ctxMap.beginPath();
            ctxMap.arc(camX, camZ, 5, 0, Math.PI * 2);
            ctxMap.fill();
        }

        // Chuy·ªÉn ƒë·ªïi click tr√™n minimap th√†nh v·ªã tr√≠ camera
        function setCameraFromMinimap(mx, my) {
            const nx = mx / minimap.width - 0.5;
            const nz = my / minimap.height - 0.5;

            cameraTargetPos.set(nx * params.width, camera.position.y, nz * params.depth);
            isCameraMoving = true; // b·∫≠t flag ƒë·ªÉ b·∫Øt ƒë·∫ßu lerp
        }


        minimap.addEventListener("mousedown", (e) => {
            isDraggingMini = true;
            const rect = minimap.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            setCameraFromMinimap(x, y);
        });

        minimap.addEventListener("mousemove", (e) => {
            if (isCameraMoving) {
                camera.position.lerp(cameraTargetPos, 0.05); // 0.05 = t·ªëc ƒë·ªô lerp, tƒÉng l√™n s·∫Ω nhanh h∆°n
                if (camera.position.distanceTo(cameraTargetPos) < 0.1) {
                    camera.position.copy(cameraTargetPos);
                    isCameraMoving = false;
                }
                controls.target.set(0, 0, 0); // lu√¥n nh√¨n v·ªÅ g·ªëc
            }

        });

        window.addEventListener("mouseup", () => isDraggingMini = false);

        // Animate
        function tick(dt) {
            requestAnimationFrame(tick);
            const delta = dt ? dt * 0.001 : 0;
            time += delta;

            if (params.flow) updateHeights(time);
            if (params.autoRotate) terrain.rotation.y += 0.05 * delta;

            // hi·ªáu ·ª©ng m∆∞a
            if (params.rain && rainGroup) {
                const pos = rainGroup.geometry.attributes.position;
                for (let i = 0; i < pos.count; i++) {
                    let y = pos.getY(i);
                    y -= 200 * delta; // t·ªëc ƒë·ªô r∆°i
                    if (y < params.waterHeight + 5) {
                        // th√™m ripple khi ch·∫°m n∆∞·ªõc
                        const x = pos.getX(i);
                        const z = pos.getZ(i);
                        createRipple(x, z);

                        y = Math.random() * 400 + 200; // reset l√™n tr√™n
                    }
                    pos.setY(i, y);
                }
                pos.needsUpdate = true;
            }


            controls.update();
            updateRipples(delta);

            renderer.render(scene, camera);
            drawMinimap();
        }
        requestAnimationFrame(tick);
    </script>
</body>

</html>